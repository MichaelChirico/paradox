% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ParamSet.R
\docType{data}
\name{ParamSet}
\alias{ParamSet}
\title{ParamSet}
\format{An object of class \code{R6ClassGenerator} of length 24.}
\usage{
ParamSet
}
\description{
A set of \link{Param} objects.
}
\section{Public members / active bindings}{

\itemize{
\item \code{set_id}            :: \code{character(1)}
ID of this param set. Settable.
\item \code{params}            :: named list of \link{Param}
Contained parameters, named with their respective IDs.
NB: The returned list contains references, so you can potentially change the objects of the param set by writing to them.
\item \code{length}            :: \code{integer(1)}
Number of contained params. Read-only.
\item \code{is_empty}          :: \code{logical(1)}
Is the param set empty? Read-only.
\item \code{class}             :: named \code{character}
Param classes of contained parameters.
Named with param IDs. Read-only.
\item \code{lower}             :: named \link{double}
Lower bounds of parameters, NA if param is not a number.
Named with param IDs. Read-only.
\item \code{upper}             :: named \link{double}
Upper bounds of parameters, NA if param is not a number.
Named with param IDs. Read-only.
\item \code{values}            :: named \code{list}
List of character vectors of allowed categorical values of contained parameters, NULL if param is not categorical.
Named with param IDs. Read-only.
\item \code{nlevels}           :: named \link{double}
Number of categorical levels per parameter, Inf for unbounded ints or any dbl.
Named with param IDs. Read-only.
\item \code{is_bounded}        :: named \code{logical(1)}
Do all parameters have finite bounds?
Named with param IDs. Read-only.
\item \code{special_vals}      :: named \code{list} of \code{list} \cr
Special values for all parameters.
Named with param IDs. Read-only.
\item \code{storage_type}      :: \code{character} \cr
Data types of params when stored in tables.
Named with param IDs. Read-only.
\item \code{tags}              :: named \code{list} of \code{character} \cr
Can be used to group and subset params.
Named with param IDs. Read-only.
\item \code{defaults}          :: named \code{list} \cr
Default values of all params. If no default exists, element is not present.
Named with param IDs. Read-only.
\item \code{trafo}             :: \code{function(x, param_set)} -> named \code{list} \cr
Transformation function. Settable. We do a bit of magic here for user convenience:
On write: User has to pass a \code{function(x, param_set)}, where x is a data.table with atomic param-columns, and it
must also returns a data.table.
The function is responsible to transform feasible configurations (rows) into
another encoding, before potentially evaluating the configuration with the target algorithm.
For the output-datatable, not many things have to hold.
It needs to have unique column names, and the target algorithm has to accept the configuration-rows.
Note that you can also create list-cols in the return value if you need to transform to complex objects.
For convenience, the self-paramset is also passed in, if you need some info from it (e.g. tags).
The user is responsible to transform this as he likes,
and has access to the \code{param_set} (e.g. to access tags or other stuff)
On read: Returns a \code{function(x)}, which does exactly what the user passed "on read",
but also allows a list-interface, and auto-passes the param set.
\item \code{has_trafo}         :: \code{logical(1)} \cr
Has the set a trafo` function?
\item \code{deps}              :: list of \link{Dependency} \cr
Parameter dependency objects, each element of the list is internally created by a call to \code{add_dep}.
\item \code{has_deps}          :: \code{logical(1)} \cr
Has the set param dependencies?
\item \code{deps_on}          :: \code{data.table} \cr
Table has cols \code{id} (\code{character(1)}) and \code{dep_parent} (\code{list} of \code{character}).
List all (direct) dependency parents of a param, through parameter IDs.
Table has one row per param and is in the same order as \code{ids()}.
}
}

\section{Public methods}{

\itemize{
\item \code{new(params)} \cr
list of \link{Param} -> \code{self}
Deep-clones all passed param objects.
\item \code{ids(class = NULL, is_bounded = NULL, tags = NULL)} \cr
\code{character}, \code{logical(1)}, \code{character} -> \code{character}
Retrieves IDs of contained params based on some selections, \code{NULL} means no restriction.
\code{class} and \code{tags} can be sets.
\item \code{add(param_set)} \cr
\link{Param} | \link{ParamSet} -> \code{self}
Adds a single param or another set to this set, all params are cloned.
\item \code{subset(ids)} \cr
\code{character} -> \code{self}
Changes the current set to the set of passed IDs.
\item \code{test(x)}, \code{check(x)}, \code{assert(x)} \cr
Three checkmate-like check-functions. Take a named list.
A point x is feasible, if it configures a subset of params,
all individual param constraints are satisfied and all dependencies are satisfied.
\item \code{add_dep(id, on, cond)} \cr
\code{character(1)}, \code{character(1)}, \link{Condition} -> \code{self}
Adds a \link{Dependency} to this set, so that param \code{id} now depends on param \code{on}.
}
}

\section{S3 methods and type converters}{

\itemize{
\item \code{as.data.table()} \cr
Compact representation as datatable. Col types are: \cr
\itemize{
\item id: character
\item lower, upper: double
\item values: list col, with NULL elements
\item special_vals: list col of list
\item is_bounded: logical
\item default: list col, with NULL elements
\item storage_type: character
\item tags: list col of character vectors
}
}
}

\keyword{datasets}
